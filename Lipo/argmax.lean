/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 16463f5f-e8e3-479c-8973-dcac49dd3667

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the problem of selecting a subset of items to maximize Discounted Cumulative Gain (DCG).

It defines the objective function `F(S)` as the maximum possible DCG achievable using a subset `S` of size `K`, optimized over all possible permutations of `S`.

The main result is `optimal_set_contains_largest_values`, which proves that any set `S` maximizing `F(S)` must consist of the `K` items with the largest gains. This is proven using a helper lemma `exchange_lemma`, which shows that replacing an item in `S` with an item outside `S` having a strictly larger gain strictly increases the objective function value.
-/

import Lipo.Prelude


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define F(S) as the maximum of ∑ v(k) g(σ(k)) over all bijections σ from {1,...,K} to S.
-/
open Finset BigOperators

variable {α : Type*} [DecidableEq α]

/-- The objective function F(S) is the maximum possible DCG achievable using items in S. -/
noncomputable def F (g : α → ℝ) (K : ℕ) (v : Fin K → ℝ) (S : Finset α) (hS : S.card = K) : ℝ :=
  let typeS := {x // x ∈ S}
  let bijections := (Finset.univ : Finset (Fin K ≃ typeS))
  let values := bijections.image (fun σ => ∑ k, v k * g (σ k))
  values.max' (by
  simp +zetaDelta at *;
  convert Fintype.card_pos_iff.mp _;
  convert Finset.univ_nonempty_iff;
  convert Fintype.ofEquiv ( Fin K ≃ S ) ( Equiv.refl _ );
  convert Fintype.card_pos_iff.mpr _;
  exact ⟨ Fintype.equivOfCardEq <| by simp +decide [ hS ] ⟩)

/-
If we replace an element i in S with an element j not in S such that g(j) > g(i), the value of F strictly increases.
-/
open Finset BigOperators

lemma exchange_lemma
  {α : Type*} [DecidableEq α]
  (g : α → ℝ) (K : ℕ) (v : Fin K → ℝ)
  (hK : K ≥ 1)
  (S : Finset α) (hS : S.card = K)
  (i : α) (hi : i ∈ S)
  (j : α) (hj : j ∉ S)
  (h_g : g i < g j)
  (hv_pos : ∀ k, 0 < v k) :
  F g K v (insert j (S.erase i)) (by
    rw [Finset.card_insert_of_notMem, Finset.card_erase_of_mem hi, hS, Nat.sub_add_cancel]
    · exact hK
    · simp [hj]) > F g K v S hS := by
        simp +decide [ F ];
        intro a
        obtain ⟨k, hk⟩ : ∃ k : Fin K, a k = ⟨i, hi⟩ := by
          exact a.surjective ⟨ i, hi ⟩;
        refine' lt_of_lt_of_le _ ( Finset.le_max' _ _ <| Finset.mem_image_of_mem _ <| Finset.mem_univ <| Equiv.ofBijective ( fun x ↦ if hx : x = k then ⟨ j, by aesop ⟩ else ⟨ a x, by aesop ⟩ ) ⟨ _, _ ⟩ );
        all_goals norm_num [ Function.Injective, Function.Surjective ];
        · refine' Finset.sum_lt_sum _ _;
          · intro l hl; split_ifs <;> simp_all +decide ;
            linarith;
          · exact ⟨ k, Finset.mem_univ _, by simpa [ hk ] using mul_lt_mul_of_pos_left h_g ( hv_pos k ) ⟩;
        · intro x y hxy; split_ifs at hxy <;> simp_all +decide [ Subtype.ext_iff ] ;
          · grind;
          · grind;
          · exact a.injective ( Subtype.ext hxy );
        · rintro x ( rfl | ⟨ hx₁, hx₂ ⟩ ) <;> [ exact ⟨ k, by aesop ⟩ ; exact ⟨ a.symm ⟨ x, hx₂ ⟩, by aesop ⟩ ]

/-
Prove that if S maximizes F, then every element in S has a g-value greater than or equal to every element in I \ S.
-/
/-- The main theorem: The optimal set S* consists of the K items with the largest g-values. -/
theorem optimal_set_contains_largest_values
  (I : Finset α)
  (g : α → ℝ)
  (K : ℕ)
  (v : Fin K → ℝ)
  (hK : K ≥ 1)
  (_hI : I.card ≥ K)
  (_hg_nonneg : ∀ i ∈ I, 0 ≤ g i)
  (hv_pos : ∀ k, 0 < v k)
  (_hv_dec : ∀ i j : Fin K, i < j → v j < v i)
  (S : Finset α) (hS_subset : S ⊆ I) (hS_card : S.card = K)
  (h_opt : ∀ S' : Finset α, S' ⊆ I → (hS' : S'.card = K) → F g K v S' hS' ≤ F g K v S hS_card) :
  ∀ i ∈ S, ∀ j ∈ I, j ∉ S → g j ≤ g i := by
    intro i hi j hj hjS;
    contrapose! h_opt;
    -- Let's define the new set $S'$ as $(S \set �minus� \{i\}) \cup \{j\}$.
    use (S.erase i) ∪ {j};
    refine' ⟨ _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
    convert exchange_lemma g K v hK S hS_card i hi j hjS h_opt hv_pos using 1