/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 910744a3-5b4d-4a31-967d-52c144a96f40

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the Gini coefficient and the exposure functions for Policy A and Policy B.
We prove that the Gini coefficient for Policy A is strictly greater than that for Policy B,
under the necessary and sufficient condition `2 * K * h < n * (2 * K - 1)`.
This condition holds, for example, when the head set is a minority (`h < n/2`) and `K >= 1` (strict if `K=1`), or `h <= n/2` and `K > 1`.
If the condition is not met (e.g. `n=2, h=1, K=1`), the Gini coefficients may be equal or reversed.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the Gini coefficient G = (∑_{i,j} |e_i - e_j|) / (2n ∑_i e_i).
-/
def gini (n : ℕ) (e : Fin n → ℚ) : ℚ :=
  (∑ i : Fin n, ∑ j : Fin n, |e i - e j|) / (2 * n * ∑ i : Fin n, e i)

/-
Under Policy A, exposure is mK/h for head items and 0 for tail items. Under Policy B, exposure is m(K-1)/h for head items and m/(n-h) for tail items.
-/
def exposureA (n h m K : ℕ) (i : Fin n) : ℚ :=
  if i < h then (m * K : ℚ) / h else 0

def exposureB (n h m K : ℕ) (i : Fin n) : ℚ :=
  if i < h then (m * (K - 1) : ℚ) / h else (m : ℚ) / (n - h)

/-
If a distribution e takes value x on a set S of size h and value y on the complement of size n-h, then Gini(e) = (2h(n-h)|x-y|) / (2n * total_sum).
-/
lemma gini_two_part {n : ℕ} {h : ℕ} (S : Finset (Fin n)) (x y : ℚ) (e : Fin n → ℚ)
    (hS : S.card = h)
    (_hSc : Sᶜ.card = n - h)
    (_he_S : ∀ i ∈ S, e i = x)
    (he_Sc : ∀ i ∈ Sᶜ, e i = y)
    (_hn : n > 0)
    (_hx : x ≥ 0) (_hy : y ≥ 0)
    (_hsum : ∑ i, e i > 0) :
    gini n e = (2 * h * (n - h) * |x - y|) / (2 * n * ∑ i, e i) := by
      refine' congrArg₂ _ _ rfl;
      -- Let's split the sum into � four� parts: $ �i� \in S$ and $j \in S$, $ �i� \in S$ and � $�j \in S^c$, $i \in S^ �c�$ and $j \in � S�$, $i \in S^c$ and $j \in S^c$.
      have h_split : ∑ i : Fin n, ∑ j : Fin n, |e i - e j| = ∑ i ∈ S, ∑ j ∈ S, |e i - e j| + ∑ i ∈ S, ∑ j ∈ Sᶜ, |e i - e j| + ∑ i ∈ Sᶜ, ∑ j ∈ S, |e i - e j| + ∑ i ∈ Sᶜ, ∑ j ∈ Sᶜ, |e i - e j| := by
        norm_num [ Finset.compl_eq_univ_sdiff ];
      simp_all +decide [ Finset.card_compl ];
      rw [ Finset.sum_congr rfl fun i hi => by rw [ he_Sc i ( Finset.mem_compl.mp hi ) ] ] ; norm_num [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul, abs_sub_comm ] ; ring_nf;
      rw [ Finset.sum_congr rfl fun i hi => by rw [ he_Sc i ( Finset.mem_compl.mp hi ) ] ] ; norm_num [ Finset.card_compl, hS ] ; ring_nf;
      rw [ Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ he_Sc i ( Finset.mem_compl.mp hi ), he_Sc j ( Finset.mem_compl.mp hj ) ] ] ; norm_num [ hS, Nat.cast_sub ( show h ≤ n from hS ▸ le_trans ( Finset.card_le_univ _ ) ( by norm_num ) ) ] ; ring;

/-
Under Policy A, exposure is mK/h for head items and 0 for tail items. Under Policy B, exposure is m(K-1)/h for head items and m/(n-h) for tail items. With the condition 2hK < n(2K-1), G(Policy A) > G(Policy B).
-/
theorem gini_policy_A_gt_policy_B (n h m K : ℕ)
  (hn : 2 ≤ n) (hK : 1 ≤ K) (hh : K ≤ h) (hhn : h < n) (hm : 0 < m)
  (h_cond : 2 * K * h < n * (2 * K - 1)) :
  gini n (exposureA n h m K) > gini n (exposureB n h m K) := by
    -- Let $S = \{i : \text{Fin } n \mid i < h\}$. Then $|S| = h$ and $|S^c| = n - � h�$.
    set S : Finset (Fin n) := Finset.univ.filter (fun i => i < h)
    have hS_card : S.card = h := by
      simp +zetaDelta at *;
      rw [ Finset.card_eq_of_bijective ];
      use fun i hi => ⟨ i, by linarith ⟩;
      · aesop;
      · aesop;
      · aesop
    have hSc_card : Sᶜ.card = n - h := by
      simp +decide [ Finset.card_compl, hS_card ];
    -- Apply the `gini_two_part` lemma to both policies.
    have h_giniA : gini n (exposureA n h m K) = (2 * h * (n - h) * ((m * K :) / h)) / (2 * n * (m * K)) := by
      convert gini_two_part S ( ( m * K : ) / h ) 0 ( exposureA n h m K ) hS_card hSc_card _ _ _ _ using 1 <;> norm_num;
      · -- By definition of $exposureA$, we know that $\sum_{i=0}^{n-1} exposureA n h m K i = mK$.
        have h_sumA : ∑ i : Fin n, exposureA n h m K i = m * K := by
          -- Split the sum into two parts: the sum over the head items and the sum over the tail items.
          have h_split_sum : ∑ i : Fin n, exposureA n h m K i = ∑ i ∈ S, (m * K : ℚ) / h + ∑ i ∈ Sᶜ, 0 := by
            rw [ Finset.sum_filter ];
            unfold exposureA; aesop;
          simp_all +decide [ mul_div_cancel₀, ne_of_gt ( show 0 < h by linarith ) ];
        rw [ h_sumA, abs_of_nonneg ( by positivity ) ] ; aesop;
      · unfold exposureA; aesop;
      · unfold exposureA; aesop;
      · grind;
      · positivity
    have h_giniB : gini n (exposureB n h m K) = (2 * h * (n - h) * |(m * (K - 1) : ℚ) / h - (m : ℚ) / (n - h)|) / (2 * n * (m * K)) := by
      have h_giniB : gini n (exposureB n h m K) = (2 * h * (n - h) * |(m * (K - 1) : ℚ) / h - (m : ℚ) / (n - h)|) / (2 * n * (∑ i, exposureB n h m K i)) := by
        apply gini_two_part S (m * (K - 1) / h : ℚ) (m / (n - h) : ℚ) (exposureB n h m K) hS_card hSc_card (by
        unfold exposureB; aesop;) (by
        unfold exposureB; aesop;) (by
        linarith) (by
        exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr ( Nat.one_le_cast.mpr hK ) ) ) ( Nat.cast_nonneg _ )) (by
        exact div_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg_of_le ( Nat.cast_le.mpr hhn.le ) )) (by
        unfold exposureB;
        rw [ Finset.sum_ite ];
        exact add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr ( Nat.one_le_cast.mpr hK ) ) ) ( Nat.cast_nonneg _ ) ) ( Finset.sum_pos ( fun _ _ => div_pos ( Nat.cast_pos.mpr hm ) ( sub_pos.mpr ( Nat.cast_lt.mpr hhn ) ) ) ⟨ ⟨ h, by linarith ⟩, by aesop ⟩ ));
      convert h_giniB using 3 ; norm_num [ exposureB ];
      -- Split the sum into two parts: the sum over the head items and the sum over the tail items.
      have h_split_sum : ∑ x : Fin n, (if x.val < h then (m * (K - 1) : ℚ) / h else (m : ℚ) / (n - h)) = (∑ x ∈ Finset.range h, (m * (K - 1) : ℚ) / h) + (∑ x ∈ Finset.Ico h n, (m : ℚ) / (n - h)) := by
        rw [ Finset.sum_ite ] ; aesop;
      simp_all +decide ;
      field_simp;
      rw [ mul_div_cancel_left₀ _ ( by norm_cast; linarith ), Nat.cast_sub hhn.le, div_self ( sub_ne_zero_of_ne ( by norm_cast; linarith ) ) ] ; ring;
    rw [ h_giniA, h_giniB ];
    gcongr;
    · exact mul_pos ( mul_pos two_pos ( Nat.cast_pos.mpr ( by linarith ) ) ) ( sub_pos.mpr ( Nat.cast_lt.mpr hhn ) );
    · rw [ abs_lt ] ; constructor <;> norm_num;
      · rw [ ← add_div, div_lt_div_iff₀ ] <;> norm_cast;
        · rw [ Int.subNatNat_eq_coe ] ; cases K <;> norm_num [ Nat.mul_succ ] at * ; nlinarith;
        · rw [ Int.subNatNat_eq_coe ] ; linarith;
        · grind;
      · exact lt_of_lt_of_le ( sub_lt_self _ <| div_pos ( by positivity ) <| sub_pos.mpr <| Nat.cast_lt.mpr hhn ) <| by gcongr ; linarith;